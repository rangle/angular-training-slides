<!-- .slide: data-background="../content/images/title-slide.jpg" -->

## Building Applications with Angular

# Unit Testing

---

## Roadmap

1. What tools should I use to test Angular applications?
1. Where should I put my tests?
1. How can I write and run simple tests?
1. How can I run the tests generated by Angular CLI?
1. How can I create mock objects for dependencies?
1. How can I simulate application changes?
1. How can I query native HTML elements?
1. How can I test asynchronous behaviors?

---

## Toolchain

- [Jasmine](https://jasmine.github.io/): behavior-driven testing framework
- [Karma](https://karma-runner.github.io/1.0/index.html): test runner
- [Istanbul](https://gotwarlost.github.io/istanbul/): coverage report generator

---

## Running Tests

- `ng test`: launches a browser for testing and watches for changes.
  - Compiles and re-runs tests as files change
- `ng test --code-coverage`: puts a coverage report in `coverage/` directory

---

## Creating Test Files

- Angular CLI automatically creates test files for components
- Adds `.spec` to test file names so Jasmine and the build system recognize them as tests
- E.g., `src/app/app.component.spec.ts` does basic tests of `AppComponent`

---

## Arrange, Act and Assert with Jasmine

Note the following in the generated tests:

- `describe` explains what the test is
- `beforeEach` runs code before each test
- `it` explains the result we are expecting
- `expect` formulates a scenario
- `toBeTruthy` is a matcher that asserts the expected outcome

---

## Testing a Pipe

- `ng generate pipe capitalize`

#####_src/app/capitalize.pipe.ts_
```ts
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
  name: 'capitalize'
})
export class CapitalizePipe implements PipeTransform {
  transform(inputText: string, args?: any): string {
    return inputText.charAt(0).toUpperCase() + inputText.slice(1);
  }
}
```

---

## Starter Code for Testing

#####_src/app/capitalize.pipe.spec.ts_
```ts
import { CapitalizePipe } from './capitalize.pipe';

describe('CapitalizePipe', () => {
  it('create an instance', () => {
    const pipe = new CapitalizePipe();
    expect(pipe).toBeTruthy();
  });
});
```

---

## Instantiate the Pipe in `beforeEach`

- We will need an instance for each test, so don't duplicate that code

#####_src/app/capitalize.pipe.spec.ts_
```ts
describe('CapitalizePipe', () => {

  let pipe;
  
  beforeEach(() => {
    pipe = new CapitalizePipe();
  });

  //…instance creation test as before…

}
```

- Have to declare `pipe` outside `beforeEach` so that it will be visible in test functions

---

## Add a Test

- Use `fdescribe` to tell Jasmine to "focus" on this test -- we have several broken tests that we'll ignore for now.

#####_src/app/capitalize.pipe.spec.ts_
```ts
fdescribe('CapitalizePipe', () => {

  //…as before…

  it('should capitalize a word', () => {
    expect(pipe.transform('foo')).toEqual('Foo');
  });
}
```

---

## Instantiating the Component or Service

- We currently do not display the number of todos in `AppComponent`.
- Let's create a method that will return the number of todos.
- Start by removing existing test code until we have the shell of a simple test for this component.

#####_src/app/app.component.spec.ts_
```ts
import { AppComponent } from './app.component';

fdescribe('AppComponent', () => {

  beforeEach(() => {

  });

  it('should count the number of items', () => {

  });

});
```

---

## Mocking Dependencies

- We need an object that matches the "shape" of `TodoService` to test `AppComponent`
- The mock object must have `addItem` method and `items` property
- `addItem` doesn't actually need to do anything
- `items` should be an array of fake todos

```ts
mockTodoService = {
  addItem: () => {}
  items: ['item 1', 'item 2', 'item 3']
};
```

- We can manually provide this to `AppComponent` by passing it to the constructor

---

## Testing Business Logic

- Here we write a failing test.
- Next, we'll create the method in `AppComponent` that will make this test pass.

#####_src/app/app.component.spec.ts_
```ts
  describe('the itemCount method', () => {

    let app: AppComponent;
    const mockToDoService;

    beforeEach(() => {
      mockToDoService = {
        addItem: () => {},
        items: ['item 1', 'item 2', 'item 3']
      };
      app = new AppComponent(mockToDoService);
    });

    it('should return the number of items', () => {
      expect(app.itemCount()).toEqual(3);
    });
  });
```

<!-- preview: http://plnkr.co/edit/XUM8Gfz08nfbQf1BhDN1?p=preview FIXME update -->

---

## When to Use TestBed

`TestBed` is a class that creates a real Angular runtime for the purposes of testing Angular elements. It is helpful when:

1. you have logic in your templates and you want to render a component class along with its template for testing
2. you want to use Angular's injector to handle dependency injection for you
3. you want to test how different elements integrate in the Angular runtime

<!-- comment needed to separate lists -->

- We do not instantiate the class we want to test when using `TestBed`
  - We let Angular do that for us
- Using the test fixture, Angular will give us the instance it created

---

## Configuring the Test Module

- We can declare `mockTodoService` as we did before and have Angular inject it for us
- TestBed will also instantiate the `AppComponent` and inject the dependency for us, but we must add it to the `declarations` array.

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ AppComponent ],
  providers:[
    { provide: ToDoService, useValue: mockToDoService }
  ]
})
```

---

## Testing Components Using ComponentFixture

- `ComponentFixture` is an testing utility that gives us access and control over the things we are testing.
- Here is how we obtain the instance of our declared component from the fixture.
  - Note that `comp` will be an instance of `AppComponent`

#####_src/app/app.component.spec.ts_
```ts
let fixture: ComponentFixture<AppComponent>;
let comp: AppComponent;

beforeEach(() => {
  TestBed.configureTestingModule({
    declarations: [ AppComponent ],
    providers: [
      { provide: ToDoService, useValue: mockToDoService }
    ]
  });

  fixture = TestBed.createComponent(AppComponent);
  comp = fixture.componentInstance;
});
```

---

## Shallow Rendering

- The above test fails because `AppComponent` itself uses components which we have not declared.
- We could provide mocks for these components, or we can do a shallow render by adding the `CUSTOM-ELEMENTS-SCHEMA`

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  schemas: [ CUSTOM_ELEMENTS_SCHEMA ]
})
```

Notes:

- `NO_ERRORS_SCHEMA` is also commonly used for shallow rendering.

---

## Providing the Real Service

- Alternatively, we can have Angular create the real service
- We can then use `TestBed` to get a reference to the injected instance

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ AppComponent ]
  providers:[ ToDoService ]
});

const toDoService = TestBed.get(ToDoService);
toDoService.items = ['item 1', 'item 2', 'item 3'];

```

---

## Importing the Real Module

- We can import the real module that declares the component and provides the service it depends on

```ts
TestBed.configureTestingModule({
  imports: [ AppModule ]
});
```

---

## Integration Testing by Querying Native Elements

- Use TestBed to get the injected ToDoService instance and assign an array of fake todo items to the `items` array.
- We can use the `debugElement` to query the generated DOM.
- The test fails because we changed the data in the service after the component was created and the view hasn't detected it.

#####_src/app/app.component.spec.ts_
```ts
describe('AppComponent', () => {
  let comp: AppComponent;
  let fixture: ComponentFixture<AppComponent>;

  beforeEach(() => {
    // TestBed.configureModule({ ...
    fixture = TestBed.createComponent(AppComponent);
    comp = fixture.componentInstance;

    const toDoService = TestBed.get(ToDoService);
    toDoService.items = ['item 1', 'item 2', 'item 3', 'item 4'];
  });

  it('should show all todo items', () => {
    const el = fixture.debugElement.query(By.css('ul'));  // from '@angular/platform-browser';
    expect(el.children.length).toEqual(4);
  });
});
```

---

## Change Detection

- We must tell Angular when to run change detection during our tests.
- The `ComponentFixture.detectChanges` method makes this possible.
- Our test should now pass.


_src/app/app.component.spec.ts_
```ts
it('should show all todo items', () => 
fixture.detectChanges();
// ...
```

---

## Change Detection

- We can indicate that we want *automatic change detection* when configuring our test module

_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ ],
  providers: [
    { provide: ComponentFixtureAutoDetect, useValue: true }
  ]
});
```

---

## Dealing With Asynchronous Behavior in Tests

- Angular tests generated by the CLI use the asynchronous function `compileComponents` and wraps it in the `async` function
- `compileComponents` is required for testing when classes reference external files through `templateUrls` and `styleUrls`.
- We usually don't need to do this
  - Webpack will inline our templates and css as part of the build process
  - But we will often need to use `async` and a similar function `fakeAsync` in our tests

---

## Running Tests in a Zone

- Jasmine can run asynchronous tests like this:

```ts
it('should...', (done) => {
  myComponent.getData().subscribe(data => {
    expect(data).toEqual({abc: 123});
    done();
  });
});
```

- Without `done` the test finishes before the callback is run
- Angular's solution is to run all of our test code inside a [Zone.js](https://github.com/angular/zone.js) zone
  where it can track all asynchronous activity and wait for all tasks to complete

---

## Interlude: Zone.js

- Zones allow Angular to create execution contexts that track the completion of asynchronous operations
- [Zone.js](https://github.com/angular/zone.js) accomplishes this by monkey patching many common asynchronous methods
- Zones are used in Angular applications to let Angular know when change detection should run
  - Since change detection is often required after asynchronous operations complete

---

## Using `async`

- The same test could be written as:

```ts
it('should...', async(() => {
  myComponent.getData().subscribe(data => {
    expect(data).toEqual({abc: 123});
  });
}));
```

- Angular will now wait for the `expect` function to complete

---

## Using `fakeAsync`

- This test tests debouncing *without* actually waiting for hundreds of milliseconds
  - Assumes `comp` has been assigned a component to test

```ts
it('should debounce change to search query for 300 ms', fakeAsync(() => {
  spyOn(comp.queryChanged, 'emit');
  comp.onChange('abc');
  tick(100);
  expect(comp.queryChanged.emit).not.toHaveBeenCalled();
  tick(200);
  expect(comp.queryChanged.emit).toHaveBeenCalledWith('abc');
}));
```

---

## Testing Services

- Test services in Angular using many of the same techniques and strategies used for testing components
- Main emphasis in testing services is data
  - Are we *getting*, *storing*, and *propagating* data correctly?
- Services will typically make HTTPS requests, so we will want to:
  - Verify the contents of the request being made (correct URL)
  - Ensure that the data we mock is returned by the right method
  - Ensure that data is being returned in the correct format

---

##  Mocking Angular’s Http Service

- Suppose we want to test a version of `TodoService` that uses `Http`'s `get` method

```ts
export class TodoService {
  public todoList = [];
  constructor(private http: Http) {}
  getTodoList() {
    return this.http.get('http://localhost:3000/todos')
      .map(response => response.json())
      .map(item => item.map(todo => this.getTodoTaskForDisplay(todo.label, todo.done, todo.id)))
      .subscribe(todos => this.todoList = todos);
  }
  getTodoTaskForDisplay(label, isComplete, id) {
    return {
      id,
      label,
      isComplete
    };
  }
}
```

---

## Creating and Injecting the Mock Object

- The backend returns data that looks like this:

```json
{
  "todos": [
    {
      "done": true,
      "id": 1,
      "label": "Wake up in the morning"
    },
    {
      "done": true,
      "id": 2,
      "label": "Grab glasses, go out the door, hit the city"
    }
  ]
}
```

---

## Creating and Injecting the Mock Object

- We can create a light mock of the `Http` service:

```ts
beforeEach(() => {
  mockHttp = { get: () => { } };

});
```

---

## Creating and Injecting the Mock Object

- We then create a spy for its `get` method
- Return an observable similar to what the real `Http` service would
- Then instantiate the service

```ts
  spyOn(mockHttp, 'get').and.returnValue(Observable.of({
    json: () => [
      { 'done': false, 'id': 1, 'label': 'item 1' },
      { 'done': true, 'id': 2, 'label': 'item 2' }
    ]
  }));

  todoService = new TodoService(mockHttp);
});
```

---

## Asserting on the Request and Response

- This method still allows us to check that the service
  - Has requested the right URL
  - Returns that expected data

```ts
it('should have the list of todos', () => {
  todoService.getTodoList();
  expect(todoService.todoList.length).toBe(2);
});
```

<!-- preview: http://plnkr.co/edit/eplM1SETfR51USVZLUlU?p=preview FIXME: update this -->
